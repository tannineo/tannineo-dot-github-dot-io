[{"title":"在Jupyter Notebook里面写Perl","url":"/2020-07-20/perl-notebook/","content":"\n之前我们解决了[Perl项目管理](https://tannineo.github.io/2020-07-17/perl-project/).\n\n我们接下来尝试为`perl`环境搭建`Jupyter`, 在`Notebook`中进行交互式的编程提高~~科研~~效率.\n\n<!-- more -->\n\n- [遗留问题: `perlbrew`下的`cpanm`](#遗留问题-perlbrew下的cpanm)\n- [Perl Notebook 环境](#perl-notebook-环境)\n  - [安装`ZeroMQ`](#安装zeromq)\n  - [安装`Jupyter`](#安装jupyter)\n  - [安装`Devel::IPerl`](#安装develiperl)\n- [试用](#试用)\n- [总结](#总结)\n\n注意, 所有操作基于OSX, 但是查看参考链接能发现Windows或者Linux的对应方案.\n\n## 遗留问题: `perlbrew`下的`cpanm`\n\n[`cpanm`](https://metacpan.org/pod/cpanm)在一般情况下都会被其他依赖的作者作为`perl`自带`cpan`的替代品, 用来安装依赖. 它输出更简洁, 本身体积和运行花销也不大.\n\n`perlbrew`的作者的文章[Perlbrew and Friends](https://perlbrew.pl/Perlbrew-and-Friends.html)提到了`cpanm`的安装. 基本问题就是: `cpanm`并不是作为`perl`官方工具链的一部分, 需要自己手动安装, 而每次切换`perl`版本会将`cpanm`从`PATH`中移除.\n\n在当前环境下安装`cpanm`, 我们可以输入:\n\n```shell\nperlbrew install-cpanm\n```\n\n## Perl Notebook 环境\n\n我们接下来的操作都基于[Devel::IPerl](https://github.com/EntropyOrg/p5-Devel-IPerl)的README.\n\n但是在执行的过程中, 我们需要搞清楚对于每个组件, 对于相应的语言, 我们会基于何种形式安装:\n\n- `python`相关的组件会被安装在沙箱环境中(本肥肥使用`pipenv`): `jupyter`\n- `perl`的通用依赖安装于对应的`perl`版本中(如`cpanm`): `ZMQ::LibZMQ3` & `Devel::IPerl`\n  - 项目依赖安装在`perl_version@project_name`的沙箱环境中\n- 其余组件安装在系统环境中, 比如数据库或者消息队列: `ZeroMQ`\n\n### 安装`ZeroMQ`\n\nOSX省心...\n\n```shell\nbrew install zmq\n```\n\n接下来安装`perl`操作`ZeroMQ`的依赖:\n\n```shell\nexport ARCHFLAGS='-arch x86_64'\ncpanm --build-args 'OTHERLDFLAGS=' ZMQ::LibZMQ3\n```\n\n### 安装`Jupyter`\n\n在工程目录下于终端输入:\n\n```shell\npipenv shell\n```\n\n进入`pipenv`沙箱, 并生成一个`./Pipfile`文件. 我们在这个沙箱中安装`jupyter`:\n\n```shell\npipenv install jupyter --skip-lock\n```\n\n`pipenv`的生成快照的速度相当之慢, 所以没有特殊需求的话, 安装dependency时可以使用`--skip-lock`跳过locking.\n\n如果直接使用`pip`安装依赖, 这个沙箱环境中也会有依赖, 但是不会被记录在`./Pipfile`文件里.\n\n### 安装`Devel::IPerl`\n\n```shell\ncpanm Devel::IPerl\n```\n\n这会经历一段漫长的编译和测试过程. 在文章撰写之日, 本肥肥发现安装会无法通过.\n\n`Devel::IPerl`作者的解决方案是手动安装特定版本的依赖:\n\n```shell\ncpanm Markdent@0.26 Markdown::Pod@0.006\n```\n\n之后重新安装`Devel::IPerl`, 可能需要force install:\n\n```shell\ncpanm Devel::IPerl --force\n```\n\n## 试用\n\n在环境下输入:\n\n```shell\niperl notebook\n```\n\n我们就会打开熟悉的`jupyter`编辑器页面. 新建notebook时选择\"IPerl 0.009\".\n\n使用过程中只有`运行下一步`和`重启kernel`的功能是完全正常的(这个项目最后一次更新是2018年...). 大家在试用的时候可以注意`jupyter`的输出日志.\n\n![notebook](./20200720_perl-notebook_01.jpg)\n\n![logs](./20200720_perl-notebook_02.jpg)\n\n但这些也足够满足我们的需求了, 我们能够执行基本的`perl`交互式编程了!\n\n引入我们在上一篇文章中安装的`./local/`和自己的`./lib`也没问题!\n\n## 总结\n\n- 理清我们所有组件的安装环境/位置.\n  - 可以的话写个README记录一下.\n- 参考`Devel::IPerl`的`RAEDME.md`安装:\n  - `ZeroMQ`\n  - `jupyter`\n  - `Devel::IPerl`(可能会出错, 详读README)\n- `iperl notebook`打开`jupyter`.\n  - bug多多, 但是能用\n\n---\n\n对, 没错, 我就是靠别人的`README.md`水了一篇博客!\n","tags":["perl","project","tool"],"categories":["programming"]},{"title":"Perl项目管理","url":"/2020-07-17/perl-project/","content":"\n文章参考: [A gentle introduction to Perl-dependency management](http://christopher.rasch-olsen.no/perl-dependency-management), 参考的内容可能过时, 所以会有所出入.\n\n本肥肥手头有一个别人给的`perl`代码, 利用它来完成自己的课题. 在尝试理解程序的情况下我在搬运代码到自己新建的项目里. 过程中碰到了一些问题让我注意到一条隔离`perl`项目依赖的工具链是有必要的.\n\n<!-- more -->\n\n如果是使用`node`尝试开发的同学一定会有所体会, `node_modules`的依赖版本控制冗余(node_modules blackhole)但是有效, 配合`nvm`也能锁定`node`运行时的版本. 而在`python`下进行开发, 基于`virtualenv`的沙箱环境配合一个配置文件(`environment.yml`之于`conda`, `Pipfile`之于`pipenv`, 或者无沙箱的`requirements.txt`之于`pip`), 可以很好的组织项目而互不影响. 类似的, `go`的`module`模式(`go.mod`)在解决依赖问题. 管理`java`的`jdk`版本有`jenv`这个工具.\n\n那么对于`perl`呢?\n\n- [需要解决的问题](#需要解决的问题)\n- [使用`perlbrew`管理`perl`版本](#使用perlbrew管理perl版本)\n- [使用`perlbrew`隔离项目依赖(沙箱)](#使用perlbrew隔离项目依赖沙箱)\n- [使用`carton`和`cpanfile`管理依赖](#使用carton和cpanfile管理依赖)\n- [总结](#总结)\n- [之后](#之后)\n  - [调整项目结构](#调整项目结构)\n  - [背后的原理](#背后的原理)\n  - [OSX下Homebrew和`perlbrew`的兼容问题](#osx下homebrew和perlbrew的兼容问题)\n  - [并不是唯一方案 / 代码](#并不是唯一方案--代码)\n\n## 需要解决的问题\n\n我们需要解决的问题有:\n\n- 固定`perl`的版本, 提供一个沙箱环境.\n  - 尽可能不去使用**可能老旧的**系统自带`perl`, 也尽可能不对依赖于自带`perl`的系统组件造成影响.\n- 隔离不同项目间的依赖.\n  - 对于同一个包, 它们可能使用了不同版本.\n- 锁定依赖的版本.\n  - 新版本的依赖接口行为可能发生变化, 或者新版本可能会引入bug.\n\n本肥肥会尝试使用[`perlbrew`](https://perlbrew.pl/)和官方的工具[`cpan`](https://www.cpan.org/)来解决上述问题. 之前本肥肥使用的是[`plenv`](https://github.com/tokuhirom/plenv), 某些地方也会有比较. 所有操作在OSX下进行.\n\n## 使用`perlbrew`管理`perl`版本\n\n遵照`perlbrew`[官网](https://perlbrew.pl/)的说明:\n\n```text\n\\curl -L https://install.perlbrew.pl | bash\n```\n\n`\\`在交互式的shell中禁止了alias, 直接运行`curl`的可执行程序. 替换为`| zsh`会使得安装失败.\n\n提示在`~/.profile`加入`source ~/perl5/perlbrew/etc/bashrc`. 但是`zsh`默认不会执行`~/.profile`里的内容, 所以我们把`source ~/perl5/perlbrew/etc/bashrc`加入自己的`~/.zshrc`.\n\n`perlbrew`查看用法, `perlbrew available`查看可安装版本. 本肥肥编辑时是`perl-5.32.0`.\n\n```shell\nperlbrew install perl-5.32.0\n```\n\n与`plenv`相同, `perlbrew`也是下载源码在本机编译, 需要等候一段时间.\n\n`perlbrew switch perl-5.32.0`将这个版本设为登录后默认版本, `perlbrew use`加版本则会在当前session切换.\n\n~~其实在日常使用`nvm`或者类似工具的时候, 都是偶尔想到了就升级到最新版本, 除非碰到问题才会使用某一特定版本或者降级,.可以把这些工具看作是快速安装运行时的工具.~~\n\n## 使用`perlbrew`隔离项目依赖(沙箱)\n\n对于某个有名字的项目, 比如`code`, 我们创建一个专门的环境用来保存依赖的lib:\n\n```shell\nperlbrew lib create code\n\nperlbrew use perl-5.32.0@code\n```\n\n命名规则是`perl版本@名称`, 缺省`@`和之前的内容会使用当前环境的版本. 在这个环境下就可以进行开发了, 可以考虑在项目根目录写一个脚本来记忆和方便运行.\n\n`perlbrew lib`查看具体用法.\n\n`plenv`并没有自带项目依赖隔离, 这一功能通过插件[`plenv-contrib`](https://github.com/miyagawa/plenv-contrib)达成, 不是特别直接. [`local::lib`](https://metacpan.org/pod/local::lib)可能是这一功能更原始的实现.\n\n输入下面的命令可以查看`@INC`(`perl`搜索依赖的路径):\n\n```shell\nperl -e \"print qq(@INC)\"\n```\n\n## 使用`carton`和`cpanfile`管理依赖\n\n相比于沙箱, 一个更直接的办法是将依赖全部下载到在项目中, 然后在编写时include.\n\n[`carton`](https://metacpan.org/pod/Carton)是能达成我们目标的工具.\n\n比如我们想尝试这个`perl`的服务器框架[`Dancer`](http://perldancer.org/), `test.pl`:\n\n```perl\n#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\n\nuse Dancer2;\n\nget '/' => sub {\n  \"Hello World!\";\n};\n\ndance;\n\n1;\n```\n\n我们尝试运行(`perl test.pl`)会发现:\n\n```text\nCan't locate Dancer2.pm in @INC ...\n```\n\n新建`cpanfile`:\n\n```text\n# cpanfile\nrequires 'Dancer2', '0.300004';\n```\n\n接下来:\n\n- 安装`carton`: `cpan Carton`.\n- 安装依赖: `carton install`, 它会读取`./cpanfile`, 安装依赖并且声称快照文件`cpanfile.snapshot`.\n\n运行, 可以:\n\n- 使用`carton`运行命令: `carton exec -- perl test.pl`.\n  - `--`能防止`carton`读取`exec`之后的一些配置flag.\n- 在`test.pl`中, 加入`use lib \"$FindBin::Bin/local/lib/perl5\";`.\n  - `FindBin::Bin`确认执行时脚本的路径.\n  - 这样我们可以用沙箱环境的`perl`直接运行: `perl test.pl`.\n\n还有其他的一些工具(都出自一个作者[miyagawa](https://github.com/miyagawa)):\n\n- `cpanm` (替代`cpan`)\n- `carmel` (实验性, 替代`carton`)\n\n## 总结\n\n1. `perlbrew`管理`perl`版本\n2. `perlbrew`创建沙箱(类似`conda`) ~~可选~~\n3. 编写`cpanfile`管理依赖版本, 使用`carton`安装到`./local/`并生成快照\n4. `use lib \"$FindBin::Bin/../local/lib/perl5\";` ~~可选~~\n\n## 之后\n\n### 调整项目结构\n\n我们可以调整一下目录结构, 更符合规范. 注意调整`use lib`的路径.\n\n```text\n.\n├── README.md\n├── bin\n│   └── test.pl\n├── cpanfile\n├── cpanfile.snapshot\n├── lib                 # use lib\n│   └── TestLib\n│       └── Tests.pm\n└── local\n    ├── bin\n    ├── cache\n    ├── lib             # use lib\n    └── man\n```\n\n我们把`\"Hello World!\"`写成`sub`并且装进了自己的module里, 在`./lib/TestLib/Tests.pm`中:\n\n```perl\npackage TestLib::Tests;\n\nuse Exporter;\n\n@ISA = qw/Exporter/;\n\n@EXPORT_OK = qw/hello/;    # use时必须显式声明hello\n\n# @EXPORT    = qw/hello/;  # use时无需声明hello\n\nsub hello {\n  return \"Hello World!\";\n}\n\n1;\n\n```\n\n最后的`test.pl`:\n\n```perl\n#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\n\nuse FindBin;\nuse lib \"$FindBin::Bin/../local/lib/perl5\";\nuse lib \"$FindBin::Bin/../lib/\";\n\nuse Dancer2;\n\nuse TestLib::Tests qw/hello/;\n\nget '/' => sub {\n  hello();\n};\n\ndance;\n\n1;\n```\n\n### 背后的原理\n\n大概率都是基于shell的环境变量更改.\n\n之后需要详细了解`perl`, 或者说`perl5`的一些基于环境变量的路径配置.\n\n### OSX下Homebrew和`perlbrew`的兼容问题\n\n问题主要是Homebrew不会使用`perlbrew`所安装的`perl`, 若是完全交给Homebrew管理, 开发中也不会涉及Homebrew所安装的组件的话, 这个问题放置也没关系.\n\n具体请查看这个[github wiki](https://github.com/gugod/App-perlbrew/wiki/Deploying-Perl-bindings-from-tools-installed-with-Homebrew-on-OS-X)\n\n### 并不是唯一方案 / 代码\n\nA Perl programming motto.\n\n> TIMTOWTDI = There Is More Than One Way To Do It\n\nSee wiki page: [TIMTOWTDI](https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it)\n","tags":["perl","project","tool","dependency"],"categories":["programming"]},{"title":"Hello World","url":"/2020-05-07/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Code\n\n```js\nfunction quicksort(X, i, j) {\n  if (i < j) {\n    p = partition(X, i, j)\n    quicksort(X, i, p - 1)\n    quicksort(X, p + 1, j)\n  }\n}\n\nfunction partition(X, i, j) {\n  var pivot = X[j]\n  var m = i\n  for (var n = i; n < j; n++) {\n    if (X[n] <= pivot) {\n      swap(X, m, n)\n      m += 1\n    }\n  }\n  swap(X, m, j)\n  return m\n}\n\nfunction swap(X, a, b) {\n  var z = X[a]\n  X[a] = X[b]\n  X[b] = z\n}\n\nvar X = []\n\nfor (var i = 0; i < 20; i++) {\n  X.push(Math.floor(Math.random() * 100))\n}\n\nquicksort(X, 0, X.length - 1)\nconsole.info(X)\n\n```\n\n## Math\n\n### Dollar Signs\n\n```tex\n\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta\n```\n\nThis inline equation $\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta$.\n\n```tex\n\\begin{aligned}\n  \\dot{x} & = \\sigma(y-x) \\\\\n  \\dot{y} & = \\rho x - y - xz \\\\\n  \\dot{z} & = -\\beta z + xy\n\\end{aligned}\n```\n\n$$\n  \\begin{aligned}\n    \\dot{x} & = \\sigma(y-x) \\\\\n    \\dot{y} & = \\rho x - y - xz \\\\\n    \\dot{z} & = -\\beta z + xy\n  \\end{aligned}\n$$\n\n## Others\n","tags":["hello world"],"categories":["misc"]}]